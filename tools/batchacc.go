// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// This tool categorizes a set of test names (camel-cased strings) into reduced set of prefixes
// Input data is read from stdin as a newline separated list of test names (as generated by the 'go test -list' command)
// Output is a JSON formated list of prefixes, to be conveniently used by GH actions 'fromJson()' function.
// THe "depth" of output prefixes is the number of segments into the cammel-cased string from the common root.
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"unicode"
)

func main() {
	depth := flag.Int("depth", 0, "The depth in the tree (in segments, from zero) to aggregate output prefixes by")
	srt := flag.Bool("sort", false, "Sorts the output elements lexicographically")
	flag.Parse()

	b := bufio.NewReader(os.Stdin)
	pt := PrefixTree{}

	for {
		dat, err := b.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println("failed to parse input: ", err)
			os.Exit(100)
		}
		pt.addString(strings.TrimSuffix(dat, "\n"))
	}

	pfx := pt.prefixesToDepth(*depth)
	if *srt {
		sort.Strings(pfx)
	}

	// print out json
	js := bytes.NewBuffer([]byte{})
	enc := json.NewEncoder(js)
	enc.Encode(pfx)
	fmt.Print(js.String())
}

func tokenizeCamelCase(s string) (out []string) {
	for len(s) > 0 {
		nx := 0
		for i := 1; i < len(s); i++ {
			nx = strings.IndexFunc(s[i:], func(r rune) bool {
				return unicode.IsUpper(r) || r == '_'
			})
			if nx == -1 {
				out = append(out, strings.TrimPrefix(s, "_"))
				return
			}
			if nx != 0 {
				nx = nx + i
				break
			}
			if i == len(s)-1 {
				nx = len(s)
			}
		}
		out = append(out, strings.TrimPrefix(s[:nx], "_"))
		s = s[nx:]
	}
	return
}

type PrefixTree map[string]PrefixTree

func (pt PrefixTree) addString(s string) {
	if len(s) == 0 {
		return
	}
	pt.addTokenized(tokenizeCamelCase(s))
}

func (pt PrefixTree) addTokenized(s []string) {
	if len(s) < 1 {
		return
	}
	var st PrefixTree
	st, ok := pt[s[0]]
	if !ok {
		st = make(PrefixTree)
	}
	st.addTokenized(s[1:])
	pt[s[0]] = st
}

func (pt PrefixTree) prefixesToDepth(d int) (px []string) {
	if d == 0 {
		for k := range pt {
			px = append(px, k)
		}
		return
	}
	for k := range pt {
		sfx := pt[k].prefixesToDepth(d - 1)
		if len(sfx) == 0 {
			px = append(px, k)
		}
		for _, s := range sfx {
			px = append(px, k+s)
		}
	}
	return
}
